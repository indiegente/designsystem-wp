const fs = require('fs');
const path = require('path');
const BabelASTConverter = require('./babel-ast-converter');

class PhpComponentTemplate {
  constructor(config) {
    this.config = config;
    this.metadata = this.loadMetadata();
  }

  loadMetadata() {
    const metadataPath = path.join(this.config.srcDir, 'metadata.json');
    if (fs.existsSync(metadataPath)) {
      return JSON.parse(fs.readFileSync(metadataPath, 'utf8'));
    }
    return {};
  }

  generate(componentName, props) {
    this.currentComponentName = componentName; // Trackear componente actual
    const functionName = `render_${componentName.replace('-', '_')}`;

    // Usar metadata para generar par√°metros
    const propsParams = this.generatePhpParameters(componentName) ||
      (props || []).map(prop => `$${prop.name} = ''`).join(', ');

    return `<?php
/**
 * ${componentName} Component
 * Auto-generated from Lit component via Babel AST
 *
 * @package ${this.config.themeName}
 * @since 1.0.0
 */

// Prevent direct access
if (!defined('ABSPATH')) {
    exit;
}

/**
 * Render ${componentName} component
 *
 * @param ${propsParams.split(',').map(p => p.trim().split('=')[0].trim()).filter(p => p.startsWith('$')).map(p => `${p} mixed`).join('\n * @param ')}
 * @return void
 */
function ${functionName}(${propsParams}) {
    // Validate required parameters
    if (!isset($theme_name)) {
        $theme_name = get_template();
    }

    ?>
    ${this.generatePhpTemplate(componentName)}
    <?php
}

/**
 * Component styles are handled by optimized Vite CSS bundle
 * No inline styles for better Core Web Vitals performance
 *
 * CSS is loaded from: assets/css/toulouse-design-system-[hash].css
 * Generated by Vite with cache-busting and minification
 */
?>`;
  }

  generatePhpTemplate(componentName) {
    // FAIL FAST: Solo generar desde componente Lit - sin fallbacks
    const dynamicTemplate = this.generateTemplateFromLitComponent(componentName);
    if (!dynamicTemplate) {
      throw new Error(`‚ùå PHP TEMPLATE ERROR: No se pudo generar template para '${componentName}'

üîß SOLUCIONES:
1. Verificar que existe src/components/${componentName}/${componentName}.js
2. Verificar que el componente Lit tiene m√©todo render() v√°lido
3. Verificar que el template HTML est√° bien formado

üí° UBICACI√ìN: src/components/${componentName}/${componentName}.js
üö® SIN FALLBACKS: Solo generaci√≥n din√°mica desde Lit soportada`);
    }

    return dynamicTemplate;
  }

  generatePhpParameters(componentName) {
    const metadata = this.metadata[componentName];
    if (!metadata) {
      throw new Error(`‚ùå PHP PARAMETERS ERROR: No metadata para componente '${componentName}'

üîß SOLUCI√ìN:
Verificar que existe configuraci√≥n en src/metadata.json para componente '${componentName}'

üí° UBICACI√ìN: src/metadata.json
üö® SIN FALLBACKS: Solo metadata expl√≠cita soportada`);
    }

    if (!metadata.parameters) {
      throw new Error(`‚ùå PHP PARAMETERS ERROR: Componente '${componentName}' no tiene parameters definidos

üîß SOLUCI√ìN:
Agregar section 'parameters' en metadata.json para componente '${componentName}'

üí° UBICACI√ìN: src/metadata.json ‚Üí "${componentName}" ‚Üí "parameters"
üö® SIN FALLBACKS: Solo parameters expl√≠citos soportados`);
    }

    return metadata.parameters
      .map(param => {
        const defaultValue = param.default ? param.default.replace(/'/g, "\\'") : '';
        return `$${param.name} = '${defaultValue}'`;
      })
      .join(', ');
  }

  /**
   * Genera template PHP din√°micamente desde el componente Lit
   */
  generateTemplateFromLitComponent(componentName) {
    const componentPath = path.join(this.config.srcDir, 'components', componentName, `${componentName}.js`);

    if (!fs.existsSync(componentPath)) {
      return null;
    }

    try {
      const componentContent = fs.readFileSync(componentPath, 'utf8');
      const htmlTemplate = this.extractHtmlTemplate(componentContent);

      if (htmlTemplate) {
        return this.convertLitTemplateToPhp(htmlTemplate, componentName);
      }
    } catch (error) {
      console.warn(`No se pudo procesar din√°micamente ${componentName}: ${error.message}`);
    }

    return null;
  }

  /**
   * Extrae el template HTML del m√©todo render() del componente Lit
   */
  extractHtmlTemplate(componentContent) {
    // Buscar el m√©todo render() y extraer el template html`...`
    const renderMatch = componentContent.match(/render\(\)\s*\{[\s\S]*?return\s+html`([\s\S]*?)`;[\s\S]*?\}/);
    
    if (renderMatch && renderMatch[1]) {
      return renderMatch[1].trim();
    }
    
    return null;
  }

  /**
   * Convierte un template Lit a PHP usando BABEL AST - NO FALLBACKS
   */
  convertLitTemplateToPhp(litTemplate, componentName) {
    console.log(`üîÑ Converting ${componentName} using Babel AST...`);

    try {
      // BABEL AST ONLY - Fail fast si no se puede convertir
      const astConverter = new BabelASTConverter(this.config);
      const phpTemplate = astConverter.convertLitTemplateToPhp(litTemplate, componentName);

      // Agregar lazy loading basado en metadata del componente
      const componentMetadata = this.metadata[componentName];
      if (componentMetadata?.performance?.lazyLoading) {
        return phpTemplate.replace(/<img([^>]*?)(?!\s+loading=)/g, '<img$1 loading="lazy"');
      }

      return phpTemplate;

    } catch (error) {
      throw new Error(`‚ùå AST CONVERSION FAILED for ${componentName}: ${error.message}\n\nüîß SOLUTION: Check component syntax and template structure`);
    }
  }


  /**
   * Genera conversiones de par√°metros JSON para componentes que los necesiten
   */
  generateParamConversions(componentName) {
    const metadata = this.metadata[componentName];
    if (!metadata || !metadata.parameters) return '';
    
    const jsonParams = metadata.parameters.filter(param => 
      param.type === 'array' || param.type === 'object' || param.name.includes('Data') || param.name.includes('Images')
    );
    
    if (jsonParams.length === 0) return '';
    
    const conversions = jsonParams.map(param => 
      `// Convertir par√°metros JSON a arrays PHP
    if (is_string($${param.name})) {
        $${param.name} = json_decode($${param.name}, true) ?: ${param.type === 'array' ? '[]' : '{}'};
    }`
    ).join('\n    ');
    
    return conversions;
  }

  /**
   * Extrae propiedades del componente Lit
   */
  extractLitProperties(componentName) {
    const componentPath = path.join(this.config.srcDir, 'components', componentName, `${componentName}.js`);
    
    if (!fs.existsSync(componentPath)) {
      return [];
    }
    
    try {
      const componentContent = fs.readFileSync(componentPath, 'utf8');
      
      // Buscar static properties = {...}
      const propsMatch = componentContent.match(/static\s+properties\s*=\s*\{([\s\S]*?)\};/);
      if (!propsMatch) return [];
      
      const propsContent = propsMatch[1];
      const properties = [];
      
      // Extraer cada propiedad
      const propMatches = propsContent.matchAll(/(\w+):\s*\{[^}]*\}/g);
      for (const propMatch of propMatches) {
        properties.push({ name: propMatch[1], default: '' });
      }
      
      // Tambi√©n buscar valores por defecto en el constructor
      const constructorMatch = componentContent.match(/constructor\(\)\s*\{[\s\S]*?\}/);
      if (constructorMatch) {
        const constructorContent = constructorMatch[0];
        properties.forEach(prop => {
          const defaultMatch = constructorContent.match(new RegExp(`this\.${prop.name}\s*=\s*['"](.*?)['"];`));
          if (defaultMatch) {
            prop.default = defaultMatch[1];
          }
        });
      }
      
      return properties;
      
    } catch (error) {
      console.warn(`No se pudieron extraer propiedades de ${componentName}: ${error.message}`);
      return [];
    }
  }
}

module.exports = PhpComponentTemplate;