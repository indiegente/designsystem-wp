const fs = require('fs');
const path = require('path');

/**
 * Validador Avanzado de Renderizado de Componentes
 * 
 * Verifica que los componentes definidos en metadata.json y page-templates.json
 * se est√©n renderizando correctamente en las p√°ginas generadas.
 */
class ComponentRenderValidator {
  constructor(config) {
    this.config = config;
    this.errors = [];
    this.warnings = [];
    this.metadata = this.loadMetadata();
    this.pageTemplates = this.loadPageTemplates();
    this.validatedComponents = new Set();
    this.validatedPages = new Set();
  }

  loadMetadata() {
    try {
      const metadataPath = path.join(this.config.srcDir, 'metadata.json');
      if (!fs.existsSync(metadataPath)) {
        this.errors.push('‚ùå metadata.json no encontrado');
        return {};
      }
      return JSON.parse(fs.readFileSync(metadataPath, 'utf8'));
    } catch (error) {
      this.errors.push(`‚ùå Error cargando metadata.json: ${error.message}`);
      return {};
    }
  }

  loadPageTemplates() {
    try {
      const templatesPath = path.join(this.config.srcDir, 'page-templates.json');
      if (!fs.existsSync(templatesPath)) {
        this.errors.push('‚ùå page-templates.json no encontrado');
        return {};
      }
      return JSON.parse(fs.readFileSync(templatesPath, 'utf8'));
    } catch (error) {
      this.errors.push(`‚ùå Error cargando page-templates.json: ${error.message}`);
      return {};
    }
  }

  async validateComponentRendering() {
    console.log('üîç Validando renderizado de componentes...');
    
    // Validar que los componentes del metadata.json est√©n implementados
    this.validateMetadataComponents();
    
    // Validar que las p√°ginas usen los componentes correctos
    this.validatePageComponentIntegration();
    
    // Validar que los par√°metros se pasen correctamente
    this.validateComponentParameters();
    
    // Validar que los templates definidos existan
    this.validateTemplateDefinitions();
    
    this.reportResults();
    return this.errors.length === 0;
  }

  validateMetadataComponents() {
    console.log('üß© Validando componentes del metadata.json...');
    
    Object.keys(this.metadata).forEach(componentName => {
      const component = this.metadata[componentName];
      
      // Saltar objetos que no son componentes (como postTypes, templates)
      if (!component.phpFunction || !component.type) {
        return;
      }
      
      this.validateComponentExists(componentName, component);
      this.validateComponentFunction(componentName, component);
      this.validatedComponents.add(componentName);
    });
  }

  validateComponentExists(componentName, component) {
    const componentPath = path.join(
      this.config.outputDir,
      this.config.themeName,
      'components',
      componentName,
      `${componentName}.php`
    );
    
    if (!fs.existsSync(componentPath)) {
      this.errors.push(`‚ùå Componente ${componentName} no generado: ${componentName}.php`);
      return false;
    }
    
    const content = fs.readFileSync(componentPath, 'utf8');
    if (!content.includes(component.phpFunction)) {
      this.errors.push(`‚ùå Funci√≥n ${component.phpFunction} no encontrada en ${componentName}.php`);
      return false;
    }
    
    console.log(`  ‚úÖ Componente ${componentName} existe y tiene funci√≥n ${component.phpFunction}`);
    return true;
  }

  validateComponentFunction(componentName, component) {
    const componentPath = path.join(
      this.config.outputDir,
      this.config.themeName,
      'components',
      componentName,
      `${componentName}.php`
    );
    
    if (!fs.existsSync(componentPath)) return;
    
    const content = fs.readFileSync(componentPath, 'utf8');
    
    // Validar que los par√°metros esperados est√©n en la funci√≥n
    if (component.parameters) {
      component.parameters.forEach(param => {
        if (!content.includes(`$${param.name}`)) {
          this.warnings.push(`‚ö†Ô∏è Par√°metro $${param.name} no encontrado en funci√≥n ${component.phpFunction}`);
        }
      });
    }
    
    // Validar que se escape correctamente el HTML (WordPress best practices)
    const hasEscaping = content.includes('esc_html') || content.includes('esc_attr') || content.includes('esc_url');
    if (!hasEscaping) {
      this.warnings.push(`‚ö†Ô∏è ${componentName} no usa funciones de escape de WordPress`);
    }
  }

  validatePageComponentIntegration() {
    console.log('üìÑ Validando integraci√≥n de componentes en p√°ginas...');
    
    Object.keys(this.pageTemplates).forEach(pageName => {
      const pageConfig = this.pageTemplates[pageName];
      this.validatePageComponents(pageName, pageConfig);
      this.validatedPages.add(pageName);
    });
  }

  validatePageComponents(pageName, pageConfig) {
    const pageFile = pageConfig.file;
    const pagePath = path.join(
      this.config.outputDir,
      this.config.themeName,
      pageFile
    );
    
    if (!fs.existsSync(pagePath)) {
      this.errors.push(`‚ùå P√°gina ${pageFile} no encontrada`);
      return;
    }
    
    const pageContent = fs.readFileSync(pagePath, 'utf8');
    
    // Validar que todos los componentes definidos est√©n siendo llamados
    if (pageConfig.components) {
      pageConfig.components.forEach(componentConfig => {
        this.validateComponentUsageInPage(pageName, pageFile, pageContent, componentConfig);
      });
    }
    
    console.log(`  ‚úÖ P√°gina ${pageFile} validada`);
  }

  validateComponentUsageInPage(pageName, pageFile, pageContent, componentConfig) {
    const componentName = componentConfig.name;
    const expectedComponent = this.metadata[componentName];
    
    if (!expectedComponent) {
      this.errors.push(`‚ùå Componente ${componentName} usado en ${pageFile} no est√° definido en metadata.json`);
      return;
    }
    
    const phpFunction = expectedComponent.phpFunction;
    
    // Verificar que la funci√≥n del componente se est√© llamando
    if (!pageContent.includes(phpFunction)) {
      this.errors.push(`‚ùå Funci√≥n ${phpFunction} no se llama en ${pageFile} (componente: ${componentName})`);
      return;
    }
    
    // Verificar que se incluya el archivo del componente
    const includePattern = `require_once.*${componentName}.*php`;
    const includeRegex = new RegExp(includePattern);
    if (!includeRegex.test(pageContent)) {
      this.warnings.push(`‚ö†Ô∏è ${pageFile} no incluye expl√≠citamente ${componentName}.php`);
    }
    
    console.log(`    ‚úÖ Componente ${componentName} usado correctamente en ${pageFile}`);
  }

  validateComponentParameters() {
    console.log('üîß Validando par√°metros de componentes...');
    
    Object.keys(this.pageTemplates).forEach(pageName => {
      const pageConfig = this.pageTemplates[pageName];
      const pageFile = pageConfig.file;
      const pagePath = path.join(
        this.config.outputDir,
        this.config.themeName,
        pageFile
      );
      
      if (!fs.existsSync(pagePath)) return;
      
      const pageContent = fs.readFileSync(pagePath, 'utf8');
      
      if (pageConfig.components) {
        pageConfig.components.forEach(componentConfig => {
          this.validateComponentParametersInPage(pageName, pageFile, pageContent, componentConfig);
        });
      }
    });
  }

  validateComponentParametersInPage(pageName, pageFile, pageContent, componentConfig) {
    const componentName = componentConfig.name;
    const expectedComponent = this.metadata[componentName];
    
    if (!expectedComponent || !expectedComponent.phpFunction) return;
    
    const phpFunction = expectedComponent.phpFunction;
    
    // Buscar llamadas a la funci√≥n en el contenido
    const functionCallRegex = new RegExp(`${phpFunction}\\s*\\([^)]*\\)`, 'g');
    const functionCalls = pageContent.match(functionCallRegex);
    
    if (!functionCalls) {
      this.warnings.push(`‚ö†Ô∏è No se encontraron llamadas a ${phpFunction} en ${pageFile}`);
      return;
    }
    
    // Validar que se pasen los par√°metros esperados seg√∫n metadata.json
    if (expectedComponent.parameters && componentConfig.props) {
      const expectedParams = expectedComponent.parameters.map(p => p.name);
      const providedProps = Object.keys(componentConfig.props);
      
      expectedParams.forEach(paramName => {
        if (!providedProps.includes(paramName)) {
          // Excepciones para par√°metros que se construyen din√°micamente
          const dynamicParams = ['testimonials', 'features', 'images'];
          if (dynamicParams.includes(paramName)) {
            this.warnings.push(`‚ö†Ô∏è Par√°metro ${paramName} se construye din√°micamente en ${componentName} (${pageFile})`);
          } else {
            this.errors.push(`‚ùå INCONSISTENCIA DE CONFIGURACI√ìN: Par√°metro ${paramName} esperado en metadata.json pero no proporcionado en page-templates.json para ${componentName} (${pageFile})`);
          }
        }
      });
    }
    
    console.log(`    ‚úÖ Par√°metros de ${componentName} validados en ${pageFile}`);
  }

  validateTemplateDefinitions() {
    console.log('üìã Validando definiciones de templates...');
    
    // Verificar que los templates definidos en metadata.json existan en page-templates.json
    if (this.metadata.templates) {
      Object.keys(this.metadata.templates).forEach(templateName => {
        const templateDef = this.metadata.templates[templateName];
        this.validateTemplateDefinition(templateName, templateDef);
      });
    }
  }

  validateTemplateDefinition(templateName, templateDef) {
    // Buscar p√°ginas que usen este template
    const pagesUsingTemplate = Object.keys(this.pageTemplates).filter(pageName => {
      return this.pageTemplates[pageName].template === templateName;
    });
    
    if (pagesUsingTemplate.length === 0) {
      this.warnings.push(`‚ö†Ô∏è Template ${templateName} definido pero no usado en ninguna p√°gina`);
      return;
    }
    
    // Validar que los componentes del template est√©n definidos
    if (templateDef.components) {
      templateDef.components.forEach(componentName => {
        if (!this.metadata[componentName]) {
          this.errors.push(`‚ùå Componente ${componentName} requerido por template ${templateName} no est√° definido en metadata.json`);
        }
      });
    }
    
    console.log(`  ‚úÖ Template ${templateName} usado en: ${pagesUsingTemplate.join(', ')}`);
  }

  reportResults() {
    console.log('\nüìä Reporte de Validaci√≥n de Renderizado:');
    console.log(`‚úÖ Componentes validados: ${this.validatedComponents.size}`);
    console.log(`‚úÖ P√°ginas validadas: ${this.validatedPages.size}`);
    
    if (this.errors.length === 0 && this.warnings.length === 0) {
      console.log('‚úÖ Todos los componentes se renderizan correctamente!');
      return;
    }

    if (this.errors.length > 0) {
      console.log(`\n‚ùå Errores de renderizado encontrados (${this.errors.length}):`);
      this.errors.forEach(error => console.log(`  ${error}`));
    }

    if (this.warnings.length > 0) {
      console.log(`\n‚ö†Ô∏è Advertencias de renderizado (${this.warnings.length}):`);
      this.warnings.forEach(warning => console.log(`  ${warning}`));
    }

    const status = this.errors.length === 0 ? '‚úÖ RENDERIZADO V√ÅLIDO' : '‚ùå ERRORES DE RENDERIZADO';
    console.log(`\nüèÅ Estado del renderizado: ${status}`);
  }
}

module.exports = ComponentRenderValidator;